/* Minimum Increments to Equalize Leaf Paths
You are given an integer n and an undirected tree rooted at node 0 with n nodes numbered from 0 to n - 1. This is represented by a 2D array edges of length n - 1, where edges[i] = [ui, vi] indicates an edge from node ui to vi .
Each node i has an associated cost given by cost[i], representing the cost to traverse that node.

The score of a path is defined as the sum of the costs of all nodes along the path.

Your goal is to make the scores of all root-to-leaf paths equal by increasing the cost of any number of nodes by any non-negative amount.

Return the minimum number of nodes whose cost must be increased to make all root-to-leaf path scores equal.
*/

class Solution {
    public:
    int res = 0;

    int min Increase(int n, vector<vector<int>>& edges, vector<int>& cost) {
        vector<vector<int>> tree(n);
        for (auto& edge : edges) {
            tree[edge[0]].push_back(edge[1]);
            tree[edge[1]].push_back(edge[0]);
        }
        dfs(0, -1, tree, cost, 0);
        return res;
    }

    int dfs(int node, int parent, vector<vector<int>>& tree, vector<int>& cost) {
        vector<int> childPaths;
        for (int child : tree[node]) {
            if (child == parent) continue;
            childPaths.push_back(dfs(child, node, tree, cost));
            
        }
    }
}